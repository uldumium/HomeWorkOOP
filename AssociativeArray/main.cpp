#include "AssociativeArray.h"


//Создать простой статический ассоциативный массив( наивную реализацию )
//
//Ассоциативным является тот массив , значения в котором ассоциированы с их ключами.
//Например , карточка клиента - это значение , а идентификатор клиента - это ключ.
//
//Класс должен быть шаблонным и должен содержать тип TKey и тип TValue соответственно.
//Кроме того , мы должны иметь возможность задать размер массива при объявлении экземпляра шаблона :
//
//template <typename TKey , typename TValue , size_t size> -пример указания типов шаблона - READY
//
//Класс должен содержать :
//-необходимые конструкторы; - READY
//-как минимум должны быть перегружены операторы присваивания и индексации( индексировать необходимо по ключу , а не по индексу ); - READY
//-другие необходимые перегрузки операторов; - ?
//-метод добавления значений( добавлять следует до тех пор , пока массив не наполнится полностью ); - READY (.put)
//-метод , проверяющий наличие ключа в массиве; - READY (.searchKey)
//-метод поиска по ключу; - READY (.searchValue)
//-метод обновления значения по ключу; - READY (.newValue)
//
//Класс реализовать простым способом.Делать реализацию хэш - таблицы НЕ НУЖНО!!!


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Мое виденье реализации данного домашнего здания
// Допускаю что мой мой класс, это некий список продуктов в продуктовом складе
// который имеет наименование товара(ключ) и количество пачек данного продукта на складе(значение)
// 
// 1 - Реализован метод, для добавления нового товара в список .put (который работает до момента, пока список не полный)
// 2 - Реализовано два конструктора, по умолчанию и конструктор копирования
// 3 - Реализован метод, который ищет наше наименование товара(ключ) в списке
// 4 - Реализован метод, поиска кол-ва пачек(значения) в списке
// 5 - Реализован метод, который перезапишет кол-во товара(значение), по наименованию (ключу)
// 6 - Реализована перегрузка оператора присваивания, на случай, если нам нужно два одинаковых списка
// 7 - По заданию реализована перегрузка оператора индексации, которая по ключу выдает значение
// 8 - Других перегрузок операторов не потребовалось, но для полноты задания, перегрузил метод сравния двух списков " == "

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int main()
{
	// Локализация "RUSSIAN"
	setlocale( 0 , "rus" );

	// Создадим список продуктов, который хранит склад
	// Склад в вмещает допустим 15 позиций
	// Ключ - название продукта, значение - это кол-во пачек, к примеру
	AssociativeArray <std::string , int , 15> milkProduct;

	// Проверка на пустоту списка
	std::cout << RED_TEXT << "Пустой ли список?\n" << DEFAULT_TEXT;
	milkProduct[ "Молоко" ];

	// Заполним некий список данными
	milkProduct.put( "Молоко" , 3 );
	milkProduct.put( "Творог" , 4 );
	milkProduct.put( "Кефир" , 67 );

	// Проверим, есть ли у нас Сырки в спивке
	std::cout << RED_TEXT << "\nМетод поиска ключа:\n" << DEFAULT_TEXT;
	milkProduct.searchKey( "Сырки" );

	// Проверим, сколько у нас Кефира по списку
	std::cout << RED_TEXT << "\nМетод поиска по ключу:\n" << DEFAULT_TEXT;
	milkProduct.searchValue( "Кефир" );

	// На склад пришло молоко, давайте внесем изменения
	std::cout << RED_TEXT << "\nМетод замены значения по ключу:\n" << DEFAULT_TEXT;
	milkProduct.newValue( "Молоко" , 45 );

	// Перегрузка оператора индексации, где индекс наш ключ, по ключу узнаем кол-во пачек
	std::cout << RED_TEXT << "\nПерегрузка оператора индексации по ключу:\n" << DEFAULT_TEXT;
	milkProduct[ "Молоко" ];
	milkProduct["Творог"];
	milkProduct[ "Кефир" ];

	// Перегрузка оператора = (и конструктора копирования соответсвенно)
	AssociativeArray <std::string , int, 15> newMilkProduct;

	// Применяем конструктор копирования (В milks копируем список milksProduct)
	AssociativeArray <std::string , int , 15> milks(milkProduct);

	// Применяем оператор =
	newMilkProduct = milkProduct;

	// Выводим кол-во значение по ключу, с помощью перегрузки оператора индексации
	std::cout << RED_TEXT << "\nПроверяем есть ли молоко в новом списке: " << DEFAULT_TEXT;
	newMilkProduct.searchKey( "Молоко" );
	std::cout << RED_TEXT << "\nПроверяем есть ли молоко в другом новом списке: " << DEFAULT_TEXT;
	milks.searchKey( "Молоко" );

	// Сравнение списков
	std::cout << RED_TEXT << "\nСравнивание списков:\n" << DEFAULT_TEXT;
	std::cout << "Список newMilkProduct и список milkProduct\n";
	newMilkProduct == milkProduct;
	std::cout << "Добавим в список milkProduct новое наименование Сырки, с количеством 45\n";
	milkProduct.put( "Сырки" , 45 );
	newMilkProduct == milkProduct;

	return 0;
}